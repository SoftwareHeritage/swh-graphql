interface Node {
  id: ID!
}

scalar SWHId

scalar DateTime

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
}

type Origin implements Node {
  # FIXME, find an idea for a UNIQUE id
  url: String!
  id: ID!
  visits(
    first: Int
    after: String
  ): VisitConnection!
}

type OriginEdge {
  cursor: String!
  node: Origin
}

type OriginConnection {
  edges: [OriginEdge]
  nodes: [Origin]
  pageInfo: PageInfo!
  totalCount: Int
}

type Visit implements Node {
  id: ID!
  date: DateTime!
  # status: VisitStatusConnection
  # origin: Origin
}

type VisitEdge {
  cursor: String!
  node: Visit
}

type VisitConnection {
  edges: [VisitEdge]
  nodes: [Visit]
  pageInfo: PageInfo!
  totalCount: Int
}

# type VisitStatus implements Node {
#   id: ID!
#   status: String!
#   date: DateTime!
#   snapshot: String
#   type: String
# }

# type VisitStatusEdge {
#   cursor: String!
#   node: [VisitStatus]
# }

# type VisitStatusConnection {
#   edges: [VisitStatusEdge]
#   nodes: [VisitStatus]
#   pageInfo: PageInfo!
#   totalCount: Int
# }

# type Snapshot implements Node {
#   id: ID!
#   # branches
# }


type Query {
  """
  Get an origin with its url
  """
  # FIXME, find some unique id to help cache
  # maybe base64 encode the URL
  origin(
    url: String!
  ): Origin

  """
  Get a list of origins
  matching the given filters
  Can be used to search for an origin
  """
  # FIMXE, use Input types to make this cleaner
  origins(
    first: Int
    after: String
  ): OriginConnection!

  """
  Get a visit object with its id
  and/or origin and visit id
  """
  # FIXME, find some unique id to help cache
  visit(
    originUrl: String!
    id: String!
  ): Visit
}


# Remove statusConnection
# Make visit obj by making multiple calls
# Make snapshot object
# Make revisionconnection
# Make contnetConnection
